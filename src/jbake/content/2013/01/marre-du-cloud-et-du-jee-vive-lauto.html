title=Marre du cloud et du JEE -> vive l'auto-hébergement et les main.
date=2013-01-08
type=post
tags=auto-hébergement,cloud,CodeStory,git,Java,JEE,Jetty,NoMock,simple
status=published
id=marre-du-cloud-et-du-jee-vive-lauto
~~~~~~
 <p>Récemment l'équipe CodeStory a lancé le concours pour la sélection 2013, informations <a href="http://code-story.net/2013/01/04/concours-2013.html">ici</a>. </p> <p>Pour participer, il faut un serveur public qui répond à des requêtes HTTPs. Pour la première étape, il faut que le serveur réponde à la requête GET "http://foobar.com:9090/?q=Quelle+est+ton+adresse+email" avec votre adresse email.<br/>Rien de bien compliqué (en tout cas pour le moment), mais il faut évidement que votre serveur puisse évoluer pour répondre aux prochaines questions. </p><br/><br/> <h1>Architecture technique</h1> <p>Pour répondre au besoin de CodeStory, il y a plusieurs solutions (en restant dans l'univers java) : <ul><li>Du JEE (ou conteneur de servlet simple) hébergé chez cloudbees ou à la maison. </li><li>Du play hébergé chez heroku, cloudbees ou à la maison. </li><li>Du Google App Engine. </li><li>Ou beaucoup plus simple :) </il></ul>Dans le cadre de CodeStory, j'ai décidé de partir sur le beaucoup plus simple (assez largement inspiré par une présentation que David Gageot avait faîte au BreizhJUG en 2011, disponible sur <a href="http://www.parleys.com/#st=5&id=2959">parleys</a>). Je suis donc parti sur un jetty embarqué et démarré depuis un simple main. </p> <p>Pour mettre en place cette "architecture", deux étapes très compliquées : <ul><li>Le pom.xml</li><li>La classe main</li></ul></p><br/> <h2>Le pom.xml</h2><p>Il faut juste ajouter la dépendance vers Jetty : <pre class="brush: xml"><br />&lt;dependency&gt;<br />    &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;<br />    &lt;artifactId&gt;jetty&lt;/artifactId&gt;<br />    &lt;version&gt;6.1.25&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre></p><br/> <h2>La classe main</h2><p>Le boulot de la classe main est simplement de démarrer le serveur et traiter les requêtes HTTP : <pre class="brush: java"><br />package fr.ybonnel.codestory;<br /><br />import org.mortbay.jetty.Server;<br />import org.mortbay.jetty.handler.AbstractHandler;<br /><br />import javax.servlet.ServletException;<br />import javax.servlet.http.HttpServletRequest;<br />import javax.servlet.http.HttpServletResponse;<br />import java.io.IOException;<br /><br />public class WebServer extends AbstractHandler {<br /><br />    public static final String QUERY_PARAMETER = "q";<br /><br />    @Override<br />    public void handle(String target, <br />                       HttpServletRequest request, <br />                       HttpServletResponse httpResponse, <br />                       int dispatch)<br />            throws IOException, ServletException {<br />        // Traitement de la requète.<br />    }<br /><br />    public static void main(String[] args) throws Exception {<br />        int port = 10080;<br />        if (args.length == 1) {<br />            port = Integer.parseInt(args[0]);<br />        }<br />        Server server = new Server(port);<br />        server.setHandler(new WebServer());<br />        server.start();<br />        server.join();<br />    }<br />}<br /></pre></p><br/> <h2>Les intérêts</h2><p>L'intérêt d'une telle "architecture" est la simplicité, ce qui se traduit par trois avantages : <ul><li>Rapidité de démarrage : 38ms sur mon poste qui n'est pas un fourdre de guerre.</li><li>Tests unitaires sans mock : grâce à la rapidité de démarrage, on peux faire des tests qui démarrent le serveur, exécutent une requête GET, et arrêtent le serveur. On se place donc à la place du client, ce qui est sans doute une garantie d'avoir le résultat attendu.</li><li>Facilité d'installation : juste un jar à exécuter (donc très simple que ce soit dans l'IDE ou dans sur un serveur).</li></ul>  </p><br/><br/> <h1>Tests unitaires</h1><p>Comme on l'a vu, pour les tests unitaires, rien de bien sorcier : <ul><li>On démarre le serveur (dans une méthode @Before, pour qu'elle soit exécutée avant chaque test)</li><li>On fait le test (envoi d'une requête GET, et vérifications sur la réponse).</li><li>On arrête le serveur (dans une méthode @After).</li></ul></p><p>Code complet du test de la première étape : <pre class="brush: java"><br />package fr.ybonnel.codestory;<br /><br />import com.google.api.client.http.*;<br />import com.google.api.client.http.javanet.NetHttpTransport;<br />import org.junit.After;<br />import org.junit.Before;<br />import org.junit.Test;<br />import org.mortbay.jetty.Server;<br /><br />import java.io.BufferedReader;<br />import java.io.IOException;<br />import java.io.InputStreamReader;<br /><br />import static junit.framework.Assert.assertEquals;<br /><br />public class WebServerTest {<br /><br />    public static final int PORT = 18080;<br />    private Server server;<br /><br />    @Before<br />    public void setup() throws Exception {<br />        WebServer.setTest(true);<br />        server = new Server(PORT);<br />        server.setHandler(new WebServer());<br />        server.start();<br /><br />        new Thread(){<br />            @Override<br />            public void run() {<br />                try {<br />                    server.join();<br />                } catch (InterruptedException ignore) {<br />                }<br />            }<br />        }.start();<br />    }<br /><br />    @After<br />    public void teardown() throws Exception {<br />        server.stop();<br />    }<br /><br />    @Test<br />    public void should_answear_to_whatsyourmail() throws Exception {<br />        String url = "http://localhost:" + PORT + "/?q=Quelle+est+ton+adresse+email";<br />        HttpResponse response = sendGetRequest(url);<br />        assertEquals("Status code must be 200", 200, response.getStatusCode());<br />        assertEquals("Response must be my mail",<br />                "ybonnel@gmail.com",<br />                responseToString(response));<br />    }<br /><br />    private static final HttpTransport HTTP_TRANSPORT = new NetHttpTransport();<br /><br />    private HttpResponse sendGetRequest(String url) throws IOException {<br />        HttpRequestFactory requestFactory =<br />                HTTP_TRANSPORT.createRequestFactory();<br />        HttpRequest request = requestFactory.buildGetRequest(new GenericUrl(url));<br />        return request.execute();<br />    }<br /><br />    private String responseToString(HttpResponse response) throws IOException {<br />        BufferedReader bufReader = new BufferedReader(new InputStreamReader(<br />                response.getContent(), response.getContentCharset()));<br />        StringBuilder builder = new StringBuilder();<br />        String line = bufReader.readLine();<br />        while (line != null) {<br />            builder.append(line);<br />            line = bufReader.readLine()<br />        }<br />        return builder.toString();<br />    }<br />}<br /></pre>Pour les tests suivant, seule la méthode @Test est à réécrire.<br/>Pour faciliter l'écriture des requêtes http, j'utilise la librairie <a href="http://code.google.com/p/google-http-java-client/">google-http-client</a>, mais si vous avez mieux, je suis preneur.<br/>EDIT : j'utilise maintenant JWebUnit, beaucoup plus simple. </p><br/><br/> <h1>Déploiement</h1><p>Je n'ai pas encore parlé d'hébergement, ce qui pour un serveur qui doit être accessible publiquement reste important. </p><p>Ayant un serveur dédié à disposition, je suis parti sur de l'auto-hébergement. Si vous me demandez "pourquoi", je vous répondrai "parce que"...</p><p>Afin de m'auto-héberger j'ai suivi trois étapes : <ul><li>Assemblage du jar</li><li>Démarrage et arrêt</li><li>Déploiement simplifié</li></ul></p><br/> <h2>Assemblage du jar</h2><p>Mon build est sous maven, créer un jar contenant les dépendances n'est donc pas très compliqué, il suffit d'ajouter la configuration qui va bien dans le pom.xml : <pre class="brush: xml"><br />&lt;build&gt;<br />    &lt;plugins&gt;<br />        &lt;plugin&gt;<br />            &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;<br />            &lt;configuration&gt;<br />                &lt;archive&gt;<br />                    &lt;manifest&gt;<br />                        &lt;mainClass&gt;fr.ybonnel.codestory.WebServer&lt;/mainClass&gt;<br />                    &lt;/manifest&gt;<br />                &lt;/archive&gt;<br />                &lt;finalName&gt;${artifactId}&lt;/finalName&gt;<br />                &lt;appendAssemblyId&gt;false&lt;/appendAssemblyId&gt;<br />                &lt;descriptorRefs&gt;<br />                    &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;<br />                &lt;/descriptorRefs&gt;<br />            &lt;/configuration&gt;<br />        &lt;/plugin&gt;<br />    &lt;/plugins&gt;<br />&lt;/build&gt;<br /></pre></p><br/> <h2>Scripts de démarrage et d'arrêt</h2><p>Pour le démarrage et l'arrêt, je ne me suis pas cassé la tête : <ul><li>Démarrage : <pre class="brush: shell">java -jar code-story.jar &gt;&gt; serveur.log 2&gt;&1 &</pre></li><li>Arrêt : <pre class="brush: shell">ps -ef | grep java | grep code-story | grep -v grep | while read a b c <br />do<br />    kill -9 $b<br />done</pre></li></ul></p><br/> <h2>Déploiement simplifié</h2><p>Le dernier truc auquel je tenais est un déploiement simple, je suis passé par deux étapes avec des logiques très différentes : <ul><li>Déploiement par update des sources</li><li>Déploiement par git push</li></ul></p> <h4>Déploiement par update des sources</h4><p>Ma première façon de déployer était relativement simple, j'ai fait un clone de mon repo git sur le serveur. Donc pour redéployer, je faisait simplement un "git pull", suivi d'une compilation et restart du serveur.<br/>Mon script de déploiement ressemblait donc à : <pre class="brush: shell"><br />git pull<br />mvn clean install assembly:single<br /></pre>Il suffisait ensuite de redémarrer le serveur pour prendre en compte le nouveau jar. </p><p>Quelques inconvénients cependant à cette technique : <ul><li>Il faut se connecter au serveur pour le mettre à jour.</li><li>On mélange les sources et la partie serveur au même endroit</li></ul></p> <h4>Déploiement par git push</h4><p>J'ai eu envie que le déploiement se résume à un "git push serveur master" depuis mon poste de dev (fortement inspiré de la façon de déployer sur heroku).</p><p><u>Première étape</u>, créer le repo git sur le serveur (depuis le serveur) : <pre class="brush: shell"><br />mkdir CodeStory.git<br />cd CodeStory.git<br />git init --bare<br /></pre>Et voilà, j'ai un repo git accessible par ssh.</p><p><u>Deuxième étape</u>, pousser le contenu actuel sur le repo (depuis mon poste de dev) : <pre class="brush: shell"><br />git remote add serveur ssh://ybonnel@XXX.XXX.XXX.XXX:XXXX/home/ybonnel/CodeStory.git<br />git push serveur master<br /></pre></p><p><u>Troisième étape</u>, créer la partie serveur (sur le serveur donc) : <pre class="brush: shell"><br />mkdir CodeStory-server<br />cd CodeStory-server/<br />cp ../CodeStory/target/code-story.jar .<br />cp ../CodeStory/scripts/* .<br /></pre>Mon répertoire "CodeStory-server" contient donc : <ul><li>Le jar</li><li>Le script de démarrage et le script d'arrêt</li></ul></p><p><u>Quatrième et dernière étape</u>, créer le hook sur le repo git. Pour ce faire, j'ai créé le script "post-receive" dans "CodeStory.git/hooks" dont voici le contenu : <pre class="brush: shell"><br />echo "Updating server..."<br />rm -rf /home/ybonnel/CodeStory<br />git clone /home/ybonnel/CodeStory.git /home/ybonnel/CodeStory<br />cd /home/ybonnel/CodeStory<br />./updateServeur.sh<br />echo "Update and restart of server are done"<br /></pre>Et voici le contenu du script "updateServeur.sh" : <pre class="brush: shell"><br />mvn clean install assembly:single<br />if [ $? -eq 0 ]<br />then<br />        cp scripts/* ../CodeStory-server/<br />        cp target/code-story.jar ../CodeStory-server/code-story.jar.new<br />        cd ../CodeStory-server<br />        ./stopServeur.sh<br />        mv code-story.jar code-story.jar.old<br />        mv code-story.jar.new code-story.jar<br />        ./startServeur.sh<br />        sleep 1<br />        tail -10 serveur.log<br />fi<br /></pre>Un fois ce hook mis en place, lorsque je fait un "git push serveur master" depuis mon poste de dev, une compile maven se lance, et si le build maven est OK, le serveur est mis à jour. Et je vois le résultat de la compile et du déploiement en direct lors de mon git push. </p><br/><br/> <h1>Et dans la vrai vie?</h1><p>Maintenant vous allez me dire, c'est bien sympa ton truc, mais dans la vrai vie, les projets sont un peu plus compliqués que simplement fournir un email en réponse à un GET...<br/>Les architectures Web modernes sont souvent composées d'une partie serveur qui répond du JSON, et une partie cliente qui joue avec (y a qu'à voir le succès de angular.js). Et avec des architectures de ce type, répondre du JSON est-il beaucoup plus compliqué que répondre une adresse email? </p><p>Pour information, mon site <a href="http://ybo-tv.ybonnel.fr">ybo-tv</a> est hébergé sur un tomcat, mais il serait relativement facile de le basculer sur une architecture de ce type (pas de stack lourde juste pour répondre du JSON, c'est facilement faisable en spécifique). </p>
