title=Code Story en java : Jajascript et les performances
date=2013-02-05
type=post
tags=CodeStory,Jajascript,Java
status=published
id=code-story-en-java-jajascript-et-les
~~~~~~
<style type="text/css"> .code {     margin: 0 2em 0 2em;     padding: 1em;     background: rgb(230, 244, 231);     border: 1px solid rgb(89, 180, 89);     white-space: pre-wrap; /* CSS3 */     white-space: -moz-pre-wrap; /* Mozilla, post millennium */     white-space: -pre-wrap; /* Opera 4-6 */     white-space: -o-pre-wrap; /* Opera 7 */     word-wrap: break-word; /* Internet Explorer 5.5+ */ }  </style> <p>Cet article est le dernier d'une série de trois articles sur ma participation à Code Story en Java. Les     articles précédents sont :</p> <ul>     <li><a href="http://www.ybonnel.fr/2013/02/ma-participation-codestory-en-java-intro.html">Ma participation à         CodeStory en java : Intro</a></li>     <li><a href="http://www.ybonnel.fr/2013/02/codestory-en-java-scalaskel-et-la.html">CodeStory en java : Scalaskel et         la calculette</a></li> </ul> <p>Je vais essayer de vous faire un retour sur l'étape qui a donné le plus de difficultés à tous les participants : Jajascript. </p> <h1>L'énoncé</h1><p>Voici l'énoncé tel que nous l'avons reçu : <div style="border:1px solid black">     <blockquote><h2 id="location_dastronef_sur_jajascript">Location d’astronef sur Jajascript</h2></blockquote>     <blockquote><p>Votre cousin par alliance, Martin O. sur la planète Jajascript vient de monter sa petite entreprise         de vol spatial privé: Jajascript Flight Rental. Il loue aux grosses corporations son astronef lorsqu’elles ont         de fortes charges ou un pépin avec leurs propres appareils. Il s’occupe de la maintenance et de l’entretien de         son petit astronef. Il ne pouvait s’en payer qu’un pour démarrer.</p>          <p>Ces grosses corporations envoient des commandes de location qui consistent en un intervalle de temps, et le             prix qu’ils sont prêts à payer pour louer l’astronef durant cet intervalle.</p>          <p>Les commandes de tous les clients sont connues plusieurs jours à l’avance. Ce qui permet de faire un planning             pour une journée. Les commandes viennent de plusieurs sociétés différentes et parfois elles se chevauchent.             On ne peut donc pas toutes les honorer.</p>          <p>Idéalement, il faut donc être capable de prendre les plus rentables, histoire de maximiser les gains de sa             petite entreprise, et de s’acheter d’autres astronefs. Votre cousin passe des heures à trouver le planning             idéal et vous demande <strong>pour un planning donné de calculer une solution qui maximise son gain</strong>.         </p>          <h3 id="exemple">Exemple</h3>          <p>Considérez par exemple le cas où la JajaScript Flight Rental à 4 commandes :</p></blockquote>     <pre class="code"><code>MONAD42 : heure de départ 0, durée 5, prix 10<br/>META18 : heure de départ 3, durée 7, prix         14<br/>LEGACY01 : heure de départ 5, durée 9, prix 8<br/>YAGNI17 : heure de départ 5, durée 9, prix         7</code></pre>     <blockquote><p>La solution optimale consiste à accepter MONAD42 et LEGACY01, et le revenu est de <code>10 + 8 =         18</code>. Remarquez qu’une solution à partir de MONAD42 et YAGNI17 est faisable (l’avion serait loué sans         interruption de 0 à 14) mais non optimale car le bénéfice ne serait que de 17.</p>          <h3 id="prcisions">Précisions</h3>          <p>L’identifiant d’un vol ne dépasse jamais 50 caractères, les heures de départs, durée et prix sont des entiers             positifs raisonnablement grands.</p>          <h3 id="serveur">Serveur</h3>          <p>Votre serveur doit répondre aux requêtes http POST de la forme             <code>http://serveur/jajascript/optimize</code> avec un payload de la forme :</p></blockquote>     <pre class="code"><code>[<br/> { "VOL": "NOM_VOL", "DEPART": HEURE, "DUREE": DUREE, "PRIX": PRIX }, ...<br/>]</code><br/></pre>     <blockquote><p>En reprenant l’exemple ci dessus :</p></blockquote>     <pre class="code"><code>[<br/> { "VOL": "MONAD42", "DEPART": 0, "DUREE": 5, "PRIX": 10 },<br/> { "VOL": "META18",         "DEPART": 3, "DUREE": 7, "PRIX": 14 },<br/> { "VOL": "LEGACY01", "DEPART": 5, "DUREE": 9, "PRIX": 8 },<br/> {         "VOL": "YAGNI17", "DEPART": 5, "DUREE": 9, "PRIX": 7 }<br/>]</code></pre>     <blockquote><p>Vous devrez répondre le résultat suivant :</p></blockquote>     <pre class="code"><code>{<br/> "gain" : 18,<br/> "path" : ["MONAD42","LEGACY01"]<br/>}</code></pre>     <blockquote><p>Le gain représentant la somme optimale, path représentant l’ordre des vols.</p>          <p>Bons calculs !</p></blockquote> </div><br/> <h1>Premier algo très naïf </h1><p>Le premier algo que j'ai pondu était très naïf, je calculais absolument     toutes les solutions possibles (voir plusieurs fois chaque solution). Voici la méthode principale de l'époque :</p> <pre class="brush:java"><br/>private void calculate(Planning actualPlanning, Collection&lt;Commande&gt; commandesToAdd) {<br/>     if (actualPlanning != null) {<br/> addToPlanningsIfBetter(actualPlanning);<br/> }<br/> for (Commande commandeToAdd :     commandesToAdd) {<br/> if (actualPlanning == null || actualPlanning.canAddCommande(commandeToAdd)) {<br/> Planning     newPlanning = new Planning(actualPlanning);<br/> newPlanning.addCommande(commandeToAdd);<br/> Collection     &lt;Commande&gt; newCommandesToAdd =<br/> Collections2.filter(commandesToAdd, new FilterCommande(commandeToAdd));<br/>         calculate(newPlanning, newCommandesToAdd);<br/> }<br/>         }<br/>}<br/></pre> <p>Dans cet algo récursif, je parcours toutes les commandes, et pour chaque commande, je regarde si elle est compatible à mon planning actuel, si elle l'est je l'ajoute au planning et je fais l'appel récursif. Cet algo est donc ni élégant ni performant, mais a le mérite de marcher. Pour les étapes précédentes cela suffisait, je me suis donc arrêté là, enfin jusqu'à la surprise. </p> <br/> <h1>La surprise</h1><p>Pour Jajascript, ils nous ont fait une petite surprise, ils se sont mis à tester les     performances... La méthode pour tester les performances était la suivante : le robot envoie une requête avec un     certain nombre de commandes, si je réponds en moins de 30 secondes, il en envoie plus, et ce jusqu'à ce que je     réponde en plus de 30 secondes. Voici la liste complète des marches utilisées par le robot :</p> <ul>     <li>5 commandes</li>     <li>10 commandes</li>     <li>15 commandes</li>     <li>20 commandes</li>     <li>25 commandes</li>     <li>30 commandes</li>     <li>35 commandes</li>     <li>40 commandes</li>     <li>45 commandes</li>     <li>50 commandes</li>     <li>55 commandes</li>     <li>60 commandes</li>     <li>65 commandes</li>     <li>70 commandes</li>     <li>75 commandes</li>     <li>80 commandes</li>     <li>85 commandes</li>     <li>90 commandes</li>     <li>95 commandes</li>     <li>100 commandes</li>     <li>150 commandes</li>     <li>250 commandes</li>     <li>500 commandes</li>     <li>1000 commandes</li>     <li>1500 commandes</li>     <li>2000 commandes</li>     <li>2500 commandes</li>     <li>3000 commandes</li>     <li>3500 commandes</li>     <li>4000 commandes</li>     <li>5000 commandes</li>     <li>10000 commandes</li>     <li>50000 commandes</li> </ul> <p>Du coup mon premier algo naïf répondait en plus de 30 secondes à partir de 30 commandes (nous ne connaissions pas le max à l'époque qui semblait être aux alentours de 100 commandes). Il a donc fallu optimiser tout ça. Je ne vais pas vous présenter tous les commits d'optimisation par lesquels je suis passés (ça représente près de 50 commits...). Je vais plutôt tenter de vous montrer les grandes étapes ainsi que les performances associées. Pour les performances, je n'ai inclus que le calcul brut (sans la couche HTTP ou Json). </p> <br/> <h1>Algo récursif optimisé</h1><p>Après quelques commits, je suis arrivé à un algo récursif un peu plus optimisé :</p> <pre class="brush:java"><br/>private void calculate(Planning actualPlanning, Collection&lt;Commande&gt; commandesToAdd) {<br/>     if (actualPlanning != null) {<br/> addToPlanningsIfBetter(actualPlanning);<br/> }<br/> Iterator     &lt;Commande&gt; itCommande = commandesToAdd.iterator();<br/><br/> while (itCommande.hasNext()) {<br/> Commande         commandeToAdd = itCommande.next();<br/> itCommande.remove();<br/> if (actualPlanning == null ||         actualPlanning.canAddCommande(commandeToAdd)) {<br/> calculate(new         Planning(actualPlanning).addCommande(commandeToAdd), newArrayList(commandesToAdd));<br/> }<br/>         }<br/>}<br/></pre> <p>Les grosses différences pour en arriver là sont (pas toutes visibles dans le code ci-dessus) :</p> <ul>     <li>Tri des commandes par heure de départ croissante</li>     <li>On ne stocke que le meilleur planning</li>     <li>On enlève la commande courante avant de continuer dans la récursivité</li>     <li>On stocke l'heure de fin d'un planning afin de savoir rapidement si une commande est compatible avec</li> </ul> <p>Pour les plus curieux, le diff complet est dispo sur  <a href="https://github.com/ybonnel/CodeStory/compare/ae22a5854164e1f5f8a2fb68c0c1a3b1899ef7fb...906502717dbb9d9cd22e8e625a40c643a4dec868">github</a>.  Cet algo tiens jusqu'à 70 commandes à peu près (c'est déjà beaucoup mieux, mais on est loin des 50000 commandes...). </p> <br/> <h1>Algo récursif très optimisé</h1><p>Afin d'aller au bout des optimisations de l'algo récursif, j'ai     modifié/enlevé tout ce qui prenait du temps sans changer l'algo. L'optimisation principale dans cette étape a été le     passage en types primitifs avec utilisation de tableau d'entier. Quand on regarde le code obtenu, on a un peu     l'impression de revoir du C... Toutes ces optimisations permettent tout de même d'atteindre les 5000 commandes     environs. Pour les plus curieux, le diff complet est disponible sur <a             href="https://github.com/ybonnel/CodeStory/compare/906502717dbb9d9cd22e8e625a40c643a4dec868...3a917905db23386d820f06ff68900a1a18884dcc">github</a>. </p><br/> <h1>Algo itératif</h1><p>Atteignant les limites du récursif, il a fallu passer à un algo itératif. Cet algo     repose sur une pile des dernières solutions trouvées, afin de regarder dans ces solutions laquelle est la meilleure     pour une commande donnée. Voici la méthode principale :</p> <pre class="brush:java"><br/>private void calculateIteratif() {<br/>    // Parcours de toutes les commandes<br/>    for (int i=0; i&lt;nbCommands;i++) {<br/>        Solution bestSolutionToAdd = null;<br/>        int bestPrice = -1;<br/>        for (Solution solution : lastSolutions) {<br/>            if (starts[i] >= solution.heureFin<br/>                    && solution.prix > bestPrice ) {<br/>                bestSolutionToAdd = solution;<br/>                bestPrice = solution.prix;<br/>            }<br/>        }<br/><br/>        lastSolutions.removeFirst();<br/><br/>        boolean[] newAceptedCommands = Arrays.copyOf(bestSolutionToAdd.acceptedCommands, bestSolutionToAdd.acceptedCommands.length);<br/>        newAceptedCommands[i] = true;<br/>        Solution newSolution = new Solution(ends[i], bestSolutionToAdd.prix + prices[i], newAceptedCommands);<br/>        lastSolutions.addLast(newSolution);<br/>    }<br/><br/>    for (Solution solution : lastSolutions) {<br/>        addToPlanningsIfBetter(solution.acceptedCommands, solution.prix);<br/><br/>    }<br/>}<br/></pre> <p>Ce passage en itératif permet d'atteindre 200000 commandes environ (ce qui était suffisant pour le concours). Pour les plus curieux, le diff complet est disponible sur <a href="https://github.com/ybonnel/CodeStory/compare/3a917905db23386d820f06ff68900a1a18884dcc...002e7f474a8db0f85ae855926290b658740ec6b8">github</a></p> <br/> <h1>Algo itératif optimisé</h1><p>Je vais maintenant vous présenter le code final obtenu après encore quelques     optimisations, et finalement un retour à de l'objet pur (ce qui me fait perdre un peu en performance, mais rend le     code tellement plus lisible). Avant d'arriver à ce résultat, je suis passé par un BitSet plutôt qu'un tableau de     booléens, ce qui m'avait fait gagner pas mal (classe à connaître donc). Si vous voulez voir tout les commits     intermédiaires, ça se passe sur <a             href="https://github.com/ybonnel/CodeStory/compare/002e7f474a8db0f85ae855926290b658740ec6b8...master">github</a>. </p><p>Voici tout d'abord la classe Solution permettant de stocker une solution trouvée : <pre class="brush:java"><br/>import com.google.common.base.Optional;<br/>import com.google.common.primitives.Ints;<br/><br/>import java.util.LinkedList;<br/>import java.util.List;<br/><br/>public class Solution implements Comparable&lt;Solution&gt;     {<br/> public final int price;<br/> public final int endTime;<br/> public final Optional     &lt;Solution&gt; oldSolution;<br/> public final Flight newFlight;<br/><br/> Solution(int price, Optional         &lt;Solution&gt; oldSolution, Flight newFlight) {<br/> this.price = price;<br/> this.oldSolution = oldSolution;<br/>             this.newFlight = newFlight;<br/> this.endTime = newFlight.endTime;<br/> }<br/><br/> public List             &lt;Flight&gt; getFlights() {<br/><br/> LinkedList                 &lt;Flight&gt; flights = new LinkedList                     &lt;Flight&gt;();<br/> flights.add(newFlight);<br/><br/> Optional                         &lt;Solution&gt; currentSolution = oldSolution;<br/> while (currentSolution.isPresent()) {<br/>                             flights.addFirst(currentSolution.get().newFlight);<br/> currentSolution =                             currentSolution.get().oldSolution;<br/> }<br/><br/> return flights;<br/> }<br/><br/> public                             boolean isBetterThan(Optional                             &lt;Solution&gt; bestSolutionToAdd) {<br/> return !bestSolutionToAdd.isPresent() || price >                                 bestSolutionToAdd.get().price;<br/> }<br/><br/> @Override<br/> public int                                 compareTo(Solution o) {<br/> return Ints.compare(price, o.price);<br/>                                 }<br/>}<br/></pre>Le point principal à noter dans cette classe, est la façon de stocker une solution. Plutôt que de stocker une image complète d'une solution, on stocke la solution précédente plus la commande qu'on lui a ajoutée. Cette technique permet d'économiser énormément de mémoire, mais permet également de diminuer énormément le coup de la création d'une solution (appel au constructeur). </p> <p>Voici maintenant la classe JajascriptService contenant tout l'algo : <pre class="brush:java"><br/>import com.google.common.base.Function;<br/>import com.google.common.base.Optional;<br/>import com.google.common.collect.Lists;<br/><br/>import java.util.Collections;<br/>import java.util.Iterator;<br/>import java.util.LinkedList;<br/>import java.util.List;<br/><br/>public class JajascriptService {<br/><br/>    /**<br/>     * Flights to optimize.<br/>     */<br/>    private List&lt;Flight&gt;     flights;<br/> /**<br/> * Last solutions found.<br/> */<br/> private LinkedList     &lt;Solution&gt; lastSolutions = new LinkedList         &lt;Solution&gt;();<br/><br/><br/> public JajascriptService(List             &lt;Flight&gt; flights) {<br/> this.flights = flights;<br/> Collections.sort(this.flights);<br/> }<br/><br/>                 public JajaScriptResponse calculate() {<br/><br/> Solution solution = calculateSolution();<br/><br/> //                 Construct the path with the array of accepted flights.<br/> List&lt;String&gt; path = Lists.transform(solution.getFlights(), new Function&lt;Flight, String&gt;() {<br/> @Override<br/> public String apply(Flight input) {<br/> return                     input.getName();<br/> }<br/> });<br/><br/> return new JajaScriptResponse(solution.price, path);<br/>                     }<br/><br/> private static class BestSolutions {<br/> Optional                     &lt;Solution&gt; bestCompatibleSolution = Optional.absent();<br/> Optional                         &lt;Solution&gt; bestSolutionWithEquivalentEndTime = Optional.absent();<br/><br/> int                             getPriceOfCompatibleSolution() {<br/> return                             getPriceOfAnOptionalSolution(bestCompatibleSolution);<br/> }<br/><br/> int                             getPriceOfEquivalentEndTimeSolution() {<br/> return                             getPriceOfAnOptionalSolution(bestSolutionWithEquivalentEndTime);<br/> }<br/><br/> private                             static int getPriceOfAnOptionalSolution(Optional                             &lt;Solution&gt; optionalSolution) {<br/> return optionalSolution.isPresent() ?                                 optionalSolution.get().price : 0;<br/> }<br/> }<br/><br/> /**<br/> * @return an optimal                                 solution.<br/> */<br/> private Solution calculateSolution() {<br/> // Iterate on all                                 flights.<br/> for (Flight flight : flights) {<br/> // Pre-calculate endTime for future                                 needs.<br/> flight.calculateEndTime();<br/><br/> BestSolutions bestSolutions =                                 getBestSolutionsForAFlight(flight);<br/><br/> int newPrice = flight.price +                                 bestSolutions.getPriceOfCompatibleSolution();<br/><br/> if (newPrice >                                 bestSolutions.getPriceOfEquivalentEndTimeSolution()) {<br/> // Add the new solution to                                 FIFO only if it's better than other solution with lower or equal endTime.<br/>                                 lastSolutions.addLast(new Solution(newPrice, bestSolutions.bestCompatibleSolution,                                 flight));<br/> }<br/><br/> if (bestSolutions.bestCompatibleSolution.isPresent()) {<br/>                                 // If we found a compatible solution, we remove all solution with endTime lower than                                 last flight startTime and lower price.<br/> removeOldSolutions(flight.startTime,                                 bestSolutions.bestCompatibleSolution.get().price);<br/> }<br/> }<br/><br/> // Search the                                 best solution in FIFO.<br/> Collections.sort(lastSolutions);<br/> return                                 lastSolutions.getLast();<br/> }<br/><br/> /**<br/> * Remove all solution with lower or                                 equal endTime than lastStartTime and lower price than priceOfCompatibleSolution.<br/> */<br/>                                 private void removeOldSolutions(int lastStartTime, int priceOfCompatibleSolution) {<br/>                                 Iterator                                 &lt;Solution&gt; lastSolutionIterator= lastSolutions.iterator();<br/><br/> while                                     (lastSolutionIterator.hasNext()) {<br/> Solution oldSolution =                                     lastSolutionIterator.next();<br/> if (oldSolution.endTime <= lastStartTime<br/> &&                                     oldSolution.price < priceOfCompatibleSolution) {<br/> lastSolutionIterator.remove();<br/>                                     }<br/> }<br/> }<br/><br/> /**<br/> * Get the best solution in {@link                                     JajascriptService#lastSolutions} for a flight.<br/> */<br/> private BestSolutions                                     getBestSolutionsForAFlight(Flight flight) {<br/> BestSolutions bestSolutions = new                                     BestSolutions();<br/> // Search the best solution in FIFO we can take for this                                     flight.<br/> for (Solution solution : lastSolutions) {<br/> if (flight.startTime >=                                     solution.endTime && solution.isBetterThan(bestSolutions.bestCompatibleSolution))                                     {<br/> bestSolutions.bestCompatibleSolution = Optional.of(solution);<br/> }<br/> if                                     (flight.endTime >= solution.endTime &&                                     solution.isBetterThan(bestSolutions.bestSolutionWithEquivalentEndTime)) {<br/>                                     bestSolutions.bestSolutionWithEquivalentEndTime = Optional.of(solution);<br/> }<br/>                                     }<br/> return bestSolutions;<br/>                                     }<br/>}<br/></pre>Cette version étant plutôt bien commentée, je vous laisse lire les commentaires... </p> <p>Au final, cette version permet de traiter 1 000 000 de commandes en 200 millisecondes. </p><br/> <h1>Différences     entre les algos</h1><p>En guise de récapitulatif, voici un petit graphique avec les performances de tous les     algos</p> <div id="perf-timeline"></div> <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.0/jquery.min.js"></script> <script src="http://cdnjs.cloudflare.com/ajax/libs/highcharts/2.3.1/highcharts.js"></script> <script>var chart = new Highcharts.Chart({  chart: {   renderTo: 'perf-timeline', type: 'line'  }, title: {   text: 'Performances Jajascript'  }, xAxis: {   title: {    text: 'Nb commandes'   }  }, yAxis: {   title: {    text: 'Temps (ms)'   }  }, series: [     {    "name": "Récursif", "data": [         [5, 10],         [10, 0],         [15, 1],         [20, 3],         [25, 6],         [30, 29],         [35, 8],         [40, 23],         [45, 105],         [50, 369],         [55, 787],         [60, 3684],         [65, 6703],         [70, 13297]     ]   },     {    "name": "Récursif optimisé", "data": [         [5, 21],         [10, 0],         [15, 0],         [20, 0],         [25, 0],         [30, 0],         [35, 0],         [40, 0],         [45, 0],         [50, 0],         [55, 0],         [60, 0],         [65, 0],         [70, 0],         [75, 0],         [80, 0],         [85, 1],         [90, 1],         [95, 2],         [100, 2],         [150, 0],         [250, 1],         [500, 21],         [1000, 112],         [1500, 303],         [2000, 572],         [2500, 1338],         [3000, 2089],         [3500, 3239],         [4000, 5015],         [5000, 11039]     ]   },     {    "name": "Itératif", "data": [         [5, 21],         [10, 0],         [15, 0],         [20, 0],         [25, 0],         [30, 0],         [35, 0],         [40, 0],         [45, 0],         [50, 1],         [55, 0],         [60, 0],         [65, 0],         [70, 0],         [75, 3],         [80, 1],         [85, 1],         [90, 1],         [95, 0],         [100, 0],         [150, 0],         [250, 1],         [500, 1],         [1000, 3],         [1500, 3],         [2000, 4],         [2500, 6],         [3000, 10],         [3500, 8],         [4000, 11],         [5000, 11],         [10000, 34],         [50000, 634],         [100000, 1929],         [200000, 7786],         [500000, 54630]     ]   },     {    "name": "Itératif optimisé", "data": [         [5, 11],         [10, 0],         [15, 0],         [20, 0],         [25, 0],         [30, 0],         [35, 0],         [40, 0],         [45, 0],         [50, 0],         [55, 0],         [60, 0],         [65, 0],         [70, 0],         [75, 0],         [80, 0],         [85, 0],         [90, 0],         [95, 0],         [100, 0],         [150, 1],         [250, 1],         [500, 3],         [1000, 7],         [1500, 4],         [2000, 3],         [2500, 3],         [3000, 6],         [3500, 4],         [4000, 4],         [5000, 4],         [10000, 4],         [50000, 19],         [100000, 32],         [200000, 49],         [500000, 100],         [1000000, 197],         [1500000, 272],         [2000000, 533],         [2500000, 2280],         [3000000, 3046],         [3500000, 1045],         [4000000, 1049],         [4500000, 1235],         [5000000, 4606],         [5500000, 10630],         [6000000, 15386]     ]   } ] }); </script><br/><br/><br/> <p>J'espère que ce retour sur ma participation à ce concours passionnant vous a plu.     J'espère avoir le temps de vous faire un petit retour sur ma participation en <a             href="https://github.com/ybonnel/CodeStory-ceylon">Ceylon</a> et en <a             href="https://github.com/ybonnel/CodeStory-scala">Scala</a>, mais je ne vous garantis rien... </p>
