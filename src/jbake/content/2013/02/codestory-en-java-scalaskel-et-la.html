title=CodeStory en java : Scalaskel et la calculette
date=2013-02-04
type=post
tags=CodeStory,Groovy,Java,Scalaskel,TDD
status=published
id=codestory-en-java-scalaskel-et-la
~~~~~~
<style type="text/css"> .code {  margin: 0 2em 0 2em;  padding: 1em;  background: rgb(230,244,231);  border: 1px solid rgb(89,180,89);  white-space: pre-wrap; /* CSS3 */  white-space: -moz-pre-wrap; /* Mozilla, post millennium */  white-space: -pre-wrap; /* Opera 4-6 */  white-space: -o-pre-wrap; /* Opera 7 */  word-wrap: break-word; /* Internet Explorer 5.5+ */ }  </style>  <p>Cet article fait suite à l'article <a href="http://www.ybonnel.fr/2013/02/ma-participation-codestory-en-java-intro.html">Ma participation à CodeStory en java : Intro</a>.<br/>Le but de cet article va être de vous parler de deux étapes du concours CodeStory : Scalaskel et la Calculette en vous présentant mon implémentation en Java. </p><br/> <h1>Scalaskel</h1><p>Voici l'énoncé tel que nous l'avons reçu par POST : </p> <div style="border:1px solid black"><blockquote><h2 id="lchoppe_de_monade_sur_scalaskel">L’échoppe de monade sur Scalaskel.</h2> <p>Sur la planète Scalaskel, une planète en marge de la galaxie, aux confins de l’univers, la monnaie se compte en cents, comme chez nous. 100 cents font un groDessimal. Le groDessimal est la monnaie standard utilisable partout sur toutes les planètes de l’univers connu. C’est un peu compliqué à manipuler, mais si on ne s’en sert pas y’a toujours des erreurs d’arrondis incroyables quand on les soustrait ou on les divise, c’est idiot, mais c’est comme ça. Sur Scalaskel, on utilise rarement des groDessimaux, on utilise des pièces plus petites : Le <strong>Foo</strong> vaut <strong>1 cent</strong>, le <strong>Bar</strong> vaut <strong>7 cents</strong>, le <strong>Qix</strong> vaut <strong>11 cents</strong> et le <strong>Baz</strong> vaut <strong>21 cents</strong>.</p> <p>Vous tenez une échoppe de monade et autres variables méta-syntaxiques sur Scalaskel. Pour faire face à l’afflux de touristes étrangers avec les poches remplies de groDessimaux vous avez besoin d’écrire un programme qui pour toute somme de 1 à 100 cents, vous donnera toutes les décompositions possibles en pièces de <strong>Foo</strong>, <strong>Bar</strong>, <strong>Qix</strong> ou <strong>Baz</strong>.</p> <p>Par exemple, 1 cent ne peut se décomposer qu’en une seule pièce <strong>Foo</strong>. Par contre 7 cents peuvent se décomposer soit en 7 pièces <strong>Foo</strong>, soit en 1 pièce <strong>Bar</strong>.</p> <h2 id="serveur_web_">Serveur Web :</h2> <p>Votre serveur doit répondre aux requêtes http GET de la forme <code>http://serveur/scalaskel/change/X</code>, <code>X</code> étant une valeur en cents de 1 à 100 cents.</p> <p>La réponse attendue est un json de la forme :</p></blockquote><pre class="code"><code>[{“foo”: w, “bar”: x, “qix”: y, “baz”: z}, …]</code></pre><blockquote><p>Exemples Pour <code>http://serveur/scalaskel/change/1</code> il faut répondre :</p></blockquote><pre class="code"><code>[ {“foo”: 1} ]</code></pre><blockquote><p>Pour <code>http://serveur/scalaskel/change/7</code> il faut répondre :</p></blockquote><pre class="code"><code>[ {“foo”: 7}, {“bar”: 1} ]</code></pre><blockquote><p>L’ordre des valeurs dans le tableau json, ainsi que le formatage n’a pas d’importance à partir du moment où c’est du json valide, il s’entend.</p> <p>Bon courage !</p></blockquote></div><p>Première chose à mettre en place, le test unitaire (et oui, même si on est pressé, le TDD c'est bien) : <pre class="brush:java"><br />import com.meterware.httpunit.WebConversation;<br />import com.meterware.httpunit.WebResponse;<br /><br />import static org.junit.Assert.assertEquals;<br /><br />public class ScalaskelTest extends WebServerTestUtil {<br /><br />    @Test<br />    public void should_answer_to_1cent() throws Exception {<br />        WebConversation wc = new WebConversation();<br />        WebResponse response = wc.getResponse(getURL() + "/scalaskel/change/1");<br />        assertEquals(200, response.getResponseCode());<br />        assertEquals("[{\"foo\":1}]", response.getText());<br />    }<br /><br />    @Test<br />    public void should_answer_to_7cent() throws Exception {<br />        WebConversation wc = new WebConversation();<br />        WebResponse response = wc.getResponse(getURL() + "/scalaskel/change/7");<br />        assertEquals(200, response.getResponseCode());<br />        assertEquals("[{\"foo\":7},{\"bar\":1}]", response.getText());<br />    }<br /><br />    @Test<br />    public void should_answer_to_11cent() throws Exception {<br />        WebConversation wc = new WebConversation();<br />        WebResponse response = wc.getResponse(getURL() + "/scalaskel/change/11");<br />        assertEquals(200, response.getResponseCode());<br />        assertEquals("[{\"foo\":11},{\"foo\":4,\"bar\":1},{\"qix\":1}]", response.getText());<br />    }<br /><br />    @Test<br />    public void should_answer_to_21cent() throws Exception {<br />        WebConversation wc = new WebConversation();<br />        WebResponse response = wc.getResponse(getURL() + "/scalaskel/change/21");<br />        assertEquals(200, response.getResponseCode());<br />        assertEquals("[{\"foo\":21},{\"foo\":14,\"bar\":1},{\"foo\":10,\"qix\":1},{\"foo\":7,\"bar\":2},{\"foo\":3,\"bar\":1,\"qix\":1},{\"bar\":3},{\"baz\":1}]", response.getText());<br />    }<br />}<br /></pre>Rien d'extraordinaire dans ce test, il contient seulement les cas basiques (en même temps, le calcul à la main est assez chiant comme ça). </p><p>Si vous avez lu l'article précédent, vous savez que mon code en l'état ne gère pas les requêtes par path du type "/scalaskel/change/1", commençons donc par là. Dans la même idée que le "QueryHandler" présenté dans l'article précendent, j'ai d'abord créé un "PathHandler" : <pre class="brush:java"><br />import fr.ybonnel.codestory.WebServerResponse;<br />import javax.servlet.http.HttpServletRequest;<br /><br />public abstract class AbstractPathHandler {<br />    public abstract WebServerResponse getResponse(HttpServletRequest request, String payLoad, String... params) throws Exception;<br />}<br /></pre>La "request" sert à récupérer deux choses : la méthode (GET/POST) et le path. Le payload est utile pour les énoncés et jajascript (données envoyées en POST). Et pour finir les params sont le résultat de l'application d'un pattern que nous verrons ensuite. </p><p>Tout comme pour les Query, j'ai mis en place un enum relativement proche, mis à part qu'il n'a pas de méthodes abstraites. Cet enum gère de manière générique le routage avec la méthode et un pattern. Voici le code complet de cet enum : <pre class="brush:java"><br />import fr.ybonnel.codestory.WebServerResponse;<br />import javax.servlet.http.HttpServletRequest;<br />import javax.servlet.http.HttpServletResponse;<br />import java.util.regex.Matcher;<br />import java.util.regex.Pattern;<br /><br />public enum PathType {<br /><br />    INSERT_ENONCE(new InsertEnonceHandler(), "/enonce/(\\d+)", "POST"),<br />    GET_ENONCES(new GetEnoncesHandler(), "/enonce(/)*", "GET"),<br />    SCALASKEL_CHANGES(new ChangeScalaskelHandler(), "/scalaskel/change/(\\d+)", "GET"),<br />    JAJASCRIPT(new OptimizeJajascriptHandler(), "/jajascript/optimize.*", "POST");<br /><br />    private AbstractPathHandler handler;<br /><br />    private Pattern pathPattern;<br />    private String method;<br /><br />    PathType(AbstractPathHandler handler, String pathPattern, String method) {<br />        this.handler = handler;<br />        this.pathPattern = Pattern.compile(pathPattern);<br />        this.method = method;<br />    }<br /><br /><br />    public Matcher isThisPath(String method, String path) {<br />        if (this.method.equals(method)) {<br />            return pathPattern.matcher(path);<br />        } else {<br />            return null;<br />        }<br />    }<br /><br />    public static WebServerResponse getResponse(HttpServletRequest request, String payLoad) throws Exception {<br />        for (PathType onePath : values()) {<br />            Matcher isThisPath = onePath.isThisPath(request.getMethod(), request.getPathInfo());<br />            if (isThisPath != null && isThisPath.matches()) {<br />                return onePath.handler.getResponse(request, payLoad, extractParameters(isThisPath));<br />            }<br />        }<br />        return new WebServerResponse(HttpServletResponse.SC_NOT_FOUND, "This path is unknown");<br />    }<br /><br />    private static String[] extractParameters(Matcher thisPath) {<br />        String[] params = new String[thisPath.groupCount()];<br />        for (int groupIndex = 1; groupIndex &lt;= thisPath.groupCount(); groupIndex++) {<br />            params[groupIndex - 1] = thisPath.group(groupIndex);<br />        }<br />        return params;<br />    }<br />}<br /></pre></p><p>Maintenant que nous avons vu la tuyauterie, passons à l'algo de Scalaskel en lui-même. Au niveau modèle, j'ai deux classes, une représentant une solution (Change), et un enum représentant les pièces : <pre class="brush:java"><br />import com.fasterxml.jackson.annotation.JsonProperty;<br /><br />public class Change {<br />    @JsonProperty<br />    private Integer foo;<br />    @JsonProperty<br />    private Integer bar;<br />    @JsonProperty<br />    private Integer qix;<br />    @JsonProperty<br />    private Integer baz;<br /><br />    public Change(Change change) {<br />        if (change != null) {<br />            foo = change.foo;<br />            bar = change.bar;<br />            qix = change.qix;<br />            baz = change.baz;<br />        }<br />    }<br /><br />    public void pay(Coin coin) {<br />        switch (coin) {<br />            case FOO:<br />                foo = foo == null ? 1 : foo + 1;<br />                break;<br />            case BAR:<br />                bar = bar == null ? 1 : bar + 1;<br />                break;<br />            case QIX:<br />                qix = qix == null ? 1 : qix + 1;<br />                break;<br />            case BAZ:<br />                baz = baz == null ? 1 : baz + 1;<br />                break;<br />        }<br />    }<br />}<br /></pre> <pre class="brush:java"><br />import java.util.List;<br /><br />import static com.google.common.collect.Lists.newArrayList;<br /><br />public enum Coin {<br />    FOO(1),<br />    BAR(7),<br />    QIX(11),<br />    BAZ(21);<br /><br />    private int value;<br /><br />    Coin(int value) {<br />        this.value = value;<br />    }<br /><br />    public int getValue() {<br />        return value;<br />    }<br /><br />    public boolean canPay(int cents) {<br />        return cents >= value;<br />    }<br /><br />    private static class ListHolder {<br />        private static final List&lt;Coin&gt; valuesAsLists = newArrayList(values());<br />    }<br /><br />    public static List&lt;Coin&gt; valuesAsLists() {<br />        return ListHolder.valuesAsLists;<br />    }<br />}<br /></pre>La classe Change contient des annotations pour la sérialisation Json avec Jackson, elle contient également un constructeur par copie servant dans l'algo, ainsi qu'une méthode pay, permettant d'ajouter une pièce à une solution. Quand à la classe Coin, elle contient une méthode "canPay" permettant de savoir si on peut ajouter la pièce pour un nombre de cents restant. Les listes sont là pour pouvoir utiliser la méthode Collections2.filter de Guava. </p><p>Et pour finir, voici la classe principale : le service permettant de faire le calcul. <pre class="brush:java"><br />import com.google.common.base.Predicate;<br />import com.google.common.collect.Collections2;<br />import com.google.common.collect.Lists;<br /><br />import java.util.List;<br /><br />public enum ScalaskelChangeService {<br />    INSTANCE;<br /><br />    public static ScalaskelChangeService getInstance() {<br />        return INSTANCE;<br />    }<br /><br />    public List&lt;Change&gt; calculateChanges(int cents) {<br />        return completeChanges(cents, null, null);<br />    }<br /><br />    private List&lt;Change&gt; completeChanges(int cents, Change currentChange, Coin lastCoin) {<br />        // Stop condition of recursivity<br />        if (cents == 0) {<br />            return Lists.newArrayList(currentChange);<br />        }<br />        List&lt;Change&gt; changes = Lists.newArrayList();<br />        for (Coin coin : Collections2.filter(<br />                Coin.valuesAsLists(),<br />                new FilterCoins(lastCoin, cents))) {<br />            Change change = new Change(currentChange);<br />            change.pay(coin);<br />            changes.addAll(completeChanges(cents - coin.getValue(), change, coin));<br />        }<br />        return changes;<br />    }<br /><br />    /**<br />     * Filter coins with this rule :<br />     * coin is keeped only if :<br />     * &lt;ul&gt;<br />     * &lt;li&gt;its value is bigger or equals thant lastCoin&lt;/li&gt;<br />     * &lt;li&gt;we can pay with the coin.&lt;/li&gt;<br />     * &lt;/ul&gt;<br />     */<br />    private static class FilterCoins implements Predicate<Coin> {<br /><br />        private int minValue;<br />        private int centsToPay;<br /><br />        private FilterCoins(Coin lastCoin, int centsToPay) {<br />            minValue = lastCoin == null ? 0 : lastCoin.getValue();<br />            this.centsToPay = centsToPay;<br />        }<br /><br />        @Override<br />        public boolean apply(Coin input) {<br />            return minValue <= input.getValue() && input.canPay(centsToPay);<br />        }<br />    }<br />}<br /></pre>Cette classe est un enum pour le côté singleton. La classe FilterCoins permet de filtrer les pièces utilisables en fonction de la dernière pièce utilisée ainsi que le nombre de cents restant à payer. Pour l'algo, il s'agit d'un algo récursif relativement bourrin. Il est sûr que si les performances avaient été un critère, j'aurais sûrement modifié l'algo. J'espère que mon code est suffisamment clair pour ne pas avoir à l'expliquer d'avantage. </p><p>La dernière partie que nous n'avons pas vu est le "PathHandler" permettant de lier le service au WebServer : <pre class="brush:java"><br />import com.fasterxml.jackson.annotation.JsonInclude;<br />import com.fasterxml.jackson.core.JsonProcessingException;<br />import com.fasterxml.jackson.databind.ObjectMapper;<br />import fr.ybonnel.codestory.WebServerResponse;<br />import fr.ybonnel.codestory.path.scalaskel.Change;<br />import fr.ybonnel.codestory.path.scalaskel.ScalaskelChangeService;<br /><br />import javax.servlet.http.HttpServletRequest;<br />import javax.servlet.http.HttpServletResponse;<br />import java.util.List;<br /><br />public class ChangeScalaskelHandler extends AbstractPathHandler {<br /><br />    private ObjectMapper objectMapper = new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL);<br /><br />    private boolean wrongParams(int centsToPay) {<br />        return centsToPay &lt;= 0 || centsToPay &gt; 100;<br />    }<br /><br />    @Override<br />    public WebServerResponse getResponse(HttpServletRequest request, String payLoad, String... params) throws JsonProcessingException {<br />        int centsToPay = Integer.parseInt(params[0]);<br />        if (wrongParams(centsToPay)) {<br />            return new WebServerResponse(HttpServletResponse.SC_FORBIDDEN, "Wrong parameters");<br />        }<br /><br />        List&lt;Change&gt; changes = ScalaskelChangeService.getInstance().calculateChanges(centsToPay);<br />        return new WebServerResponse(HttpServletResponse.SC_OK, objectMapper.writeValueAsString(changes));<br />    }<br />}<br /></pre>Dans cette classe, vous pouvez voir une petite protection afin d'éviter de faire tomber le serveur en demandant le change de 1.000.000 de cents. On peut également y voir la sérialisation Json avec Jackson, mais rien de sorcier non plus. </p><br/> <h1>La calculette</h1><p>Pour cet exercice, pas d'énoncé, la première requête reçue fut : "/?q=1+1" à laquelle on se doute qu'il faut répondre "2". Je ne vais pas vous détailler toutes les étapes par lesquelles je suis passé pour arriver au bout. Voici la liste des requêtes reçues (dans l'ordre) : <ul><li>1+1</li><li>2+2</li><li>3+3</li><li>4+4</li><li>5+5</li><li>6+6</li><li>7+7</li><li>8+8</li><li>9+9</li><li>1*1</li><li>2*2</li><li>3*3</li><li>4*4</li><li>5*5</li><li>6*6</li><li>7*7</li><li>8*8</li><li>9*9</li><li>1+2*2</li><li>(1+2)*2</li><li>(1+2+3+4+5+6+7+8+9+10)*2</li><li>(1+2)/2</li><li>((1+2)+3+4+(5+6+7)+(8+9+10)*3)/2*5</li><li>1,5*4</li><li>((1,1+2)+3,14+4+(5+6+7)+(8+9+10)*4267387833344334647677634)/2*553344300034334349999000</li><li>((1,1+2)+3,14+4+(5+6+7)+(8+9+10)*4267387833344334647677634)/2*553344300034334349999000/31878018903828899277492024491376690701584023926880</li><li>(-1)+(1)</li><li>1,0000000000000000000000000000000000000000000000001*1,0000000000000000000000000000000000000000000000001</li></ul>Cette liste vous permet sans doute de voir par quelles étapes je suis passé : <ul><li>Gestion des sommes</li><li>Gestion des multiplication</li><li>Gestion des priorités</li><li>Gestion des parenthèses</li><li>Gestion des divisions</li><li>Gestion des décimaux</li><li>Gestion des grands nombres</li><li>Gestion des nombres négatifs</li><li>Gestion des nombres de décimales élevés</li></ul>Pour la première version de mon code, j'ai tout fait à la main à grand coup de Pattern, voici le résultat final : <pre class="brush:java"><br />import com.google.common.base.Throwables;<br />import fr.ybonnel.codestory.query.calculate.Operator;<br />import fr.ybonnel.codestory.query.calculate.SearchParanthesis;<br /><br />import java.math.BigDecimal;<br />import java.math.RoundingMode;<br />import java.text.DecimalFormat;<br />import java.text.DecimalFormatSymbols;<br />import java.text.NumberFormat;<br />import java.text.ParseException;<br />import java.util.ArrayList;<br />import java.util.List;<br />import java.util.Locale;<br />import java.util.regex.Matcher;<br />import java.util.regex.Pattern;<br /><br />public class CalculateQueryHandler extends AbstractQueryHandler {<br /><br />    private static final String NOMBRE = "\\-?\\d+\\.?\\d*";<br />    private static final String PATTERN_DIVIDE = "(" + NOMBRE + ")/(" + NOMBRE + ")";<br />    private static final String PATTERN_MULTIPLY = "(" + NOMBRE + ")\\*(" + NOMBRE + ")";<br />    private static final String PATTERN_ADD = "(" + NOMBRE + ")\\+(" + NOMBRE + ")";<br /><br />    // operators list by priority.<br />    private List<Operator> operators = new ArrayList<Operator>() {{<br />        // operator divide.<br />        add(new Operator(PATTERN_DIVIDE) {<br />            @Override<br />            public BigDecimal operate(BigDecimal a, BigDecimal b) {<br />                try {<br />                    return a.divide(b);<br />                } catch (ArithmeticException exception) {<br />                    return a.divide(b, 1000, RoundingMode.HALF_UP);<br />                }<br />            }<br />        });<br />        // Operator Multiply.<br />        add(new Operator(PATTERN_MULTIPLY) {<br />            @Override<br />            public BigDecimal operate(BigDecimal a, BigDecimal b) {<br />                return a.multiply(b);<br />            }<br />        });<br />        // Operator Add.<br />        add(new Operator(PATTERN_ADD) {<br />            @Override<br />            public BigDecimal operate(BigDecimal a, BigDecimal b) {<br />                return a.add(b);<br />            }<br />        });<br />    }};<br /><br />    private Pattern patternParenthesis = Pattern.compile("\\((.*)\\)");<br />    private NumberFormat format = new DecimalFormat("#0.#", new DecimalFormatSymbols(Locale.FRANCE));<br /><br />    public CalculateQueryHandler() {<br />        format.setMaximumFractionDigits(500);<br />    }<br /><br />    @Override<br />    public String getResponse(String query) {<br />        String result = null;<br />        try {<br />            result = calculateWithParenthesis(query.replace(' ', '+').replace(',', '.'));<br />        } catch (ParseException e) {<br />            Throwables.propagate(e);<br />        }<br /><br />        try {<br />            BigDecimal retour = new BigDecimal(result);<br />            return format.format(retour);<br />        } catch (NumberFormatException numberFormatException) {<br />            numberFormatException.printStackTrace();<br />            return null;<br />        }<br />    }<br /><br />    private String calculateWithParenthesis(String calculateQuery) throws ParseException {<br />        Matcher matcherParenthsis = patternParenthesis.matcher(calculateQuery);<br /><br />        while (matcherParenthsis.find()) {<br />            SearchParanthesis searchParanthesis = new SearchParanthesis(calculateQuery).invoke();<br />            int start = searchParanthesis.getStart();<br />            int end = searchParanthesis.getEnd();<br /><br />            // Calculate the content of parenthesis.<br />            String queryBetweenParenthesis = calculateQuery.substring(start + 1, end - 1);<br />            String result = calculateWithoutParenthesis(queryBetweenParenthesis);<br /><br />            // Replace the parenthesis group with result.<br />            calculateQuery = calculateQuery.substring(0, start) + result + calculateQuery.substring(end);<br />            matcherParenthsis = patternParenthesis.matcher(calculateQuery);<br />        }<br /><br />        calculateQuery = calculateWithoutParenthesis(calculateQuery);<br />        return calculateQuery;<br />    }<br /><br />    private String calculateWithoutParenthesis(String calculateQuery) throws ParseException {<br /><br />        for (Operator operator : operators) {<br />            Matcher matcher = operator.matcher(calculateQuery);<br /><br />            while (matcher.find()) {<br />                BigDecimal a = new BigDecimal(matcher.group(1));<br />                BigDecimal b = new BigDecimal(matcher.group(2));<br />                BigDecimal result = operator.operate(a, b);<br /><br />                // Replace sur operation in string by result.<br />                calculateQuery = calculateQuery.substring(0, matcher.start()) + result.toString() + calculateQuery.substring(matcher.end());<br /><br />                matcher = operator.matcher(calculateQuery);<br />            }<br />        }<br /><br />        return calculateQuery;<br />    }<br />}<br /></pre>Je vous l'accorde, le code est relativement complexe, mais je suis assez fier d'avoir pondu une calculette à la main. </p><p>Devant tout ce code, j'ai décidé de simplifier tout ça grâce à groovy, vous allez voir le code est grandement simplifié : <pre class="brush:java"><br />import groovy.lang.GroovyShell;<br />import java.text.DecimalFormat;<br />import java.text.DecimalFormatSymbols;<br />import java.text.NumberFormat;<br />import java.util.Locale;<br /><br />public class CalculateQueryHandler extends AbstractQueryHandler {<br />    private NumberFormat format = new DecimalFormat("#0.#", new DecimalFormatSymbols(Locale.FRANCE));<br />    private GroovyShell shell = new GroovyShell();<br /><br />    public CalculateQueryHandler() {<br />        format.setMaximumFractionDigits(500);<br />    }<br /><br />    @Override<br />    public String getResponse(String query) {<br />        Object object = shell.evaluate("return " + query.replace(' ', '+').replace(',', '.'));<br />        return formatGroovyReturn(object);<br />    }<br /><br />    private String formatGroovyReturn(Object object) {<br />        try {<br />            return format.format(object);<br />        } catch (NumberFormatException numberFormatException) {<br />            numberFormatException.printStackTrace();<br />            return null;<br />        }<br />    }<br />}<br /></pre>Et voilà, merci groovy, finalement pas besoin de réinventer la roue... </p><br/><br/><br/><p>Cet article est le deuxième d'une série de trois articles dont le dernier est sans doute le plus intéressant : <a href="http://www.ybonnel.fr/2013/02/code-story-en-java-jajascript-et-les.html">Jajascript et les performance</a>. Afin de vous donner un avant-goût, vous pouvez regarder l'article sur le blog Code Story : <a href="http://code-story.net/2013/02/02/jajascript.html">Location d’astronef sur Jajascript</a>. </p>  
