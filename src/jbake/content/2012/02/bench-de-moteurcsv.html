title=Bench de MoteurCsv
date=2012-02-22
type=post
tags=CSV,Java
status=published
id=bench-de-moteurcsv
~~~~~~
Suite à la publication du billet <a href="/2012/02/moteurcsv-le-jpa-du-csv.html">MoteurCsv le JPA du CSV</a>, quelqu'un m'a demandé si j'avais fait un bench. N'en ayant pas fait, je me suis lancé.<br />Les sources du bench sont disponibles sur <a href="http://github.com/ybonnel/BenchMoteurCsv">github</a><br /><br /><h1> Génération du fichier de test</h1>Le "cahier des charges" fournit par "bbo" était le suivant :<br /><ul><li>~10 000 000 de lignes.</li><li>~200 caractères par ligne.</li><li>~20 champs (4/5 gros champs autour de 20 caractères.)</li></ul>C'est avec ces contraintes que j'ai créé la classe <a href="https://github.com/ybonnel/BenchMoteurCsv/blob/master/src/main/java/fr/ybo/benchmoteurcsv/GenerationFchierCsv.java">GenerationFchierCsv</a>.<br />Cette classe génère donc un fichier de 10 000 000 de lignes contenant des lignes avec 20 champs : <br /><ul><li>Quatre champs de type String et de 30 caractères</li><li>Quatre champs de type Boolean (1 ou 0)</li><li>Quatre champs de type Integer et de 5 chiffres</li><li>Quatre champs de type Double et de 5 chiffres avant la virgule et 5 chiffres après la virgule</li><li>Quatre champs de type String et de 5 caractères</li></ul><br />Voici le résultat de la génération du fichier :<br />Statistiques sur la taille des lignes : <br /><ul><li>Minimum : 215 caractères</li><li>Maximum : 227 caractères</li><li>Moyenne : 225,666 caractères</li></ul>Taille du fichier : 2 266 666 035 octets soit 2,11 Go<br />Génération en 70 576ms <br />Le résultat est donc à peu près conforme au cahier des charges. <br /><br /><h1> Constitution du bench</h1>Le bench est réalisé par la classe <a href="https://github.com/ybonnel/BenchMoteurCsv/blob/master/src/main/java/fr/ybo/benchmoteurcsv/Bench.java">Bench</a> (<span class="Apple-style-span" style="font-size: xx-small;">je sais, je suis trop bon pour trouver des noms</span>).<br />Pour le bench, je ne pouvais pas utiliser la méthode permettant de parser tout le fichier et qui renvoie une liste d'objet. Vu la taille du fichier, il est facile de comprendre que le mettre entièrement en mémoire ne serait pas une bonne idée.<br />Heureusement le moteur contient une autre méthode permettant de réaliser un traitement pour chaque ligne : <a href="http://ybonnel.github.com/MoteurCsv/apidocs/fr/ybo/moteurcsv/MoteurCsv.html#parseFileAndInsert(java.io.Reader,%20java.lang.Class,%20fr.ybo.moteurcsv.modele.InsertObject)">MoteurCsv.parseFileAndInsert</a><br />Dans le cadre du bench j'ai donc utilisé cette méthode en ne réalisant aucun traitement : <br /><pre class="brush: java">public static void bench1() throws FileNotFoundException {<br />    long startTime = System.currentTimeMillis();<br />    moteur.parseFileAndInsert(new FileReader(fichier), ObjetCsv.class,<br />        new InsertObject&lt;objetcsv&gt;() {<br />            @Override<br />            public void insertObject(ObjetCsv objet) {<br />                // On ne fait rien dans le cadre du bench.<br />            }<br />        });<br />    long elapsedTime = (System.currentTimeMillis() - startTime);<br />    System.out.println("Lecture du fichier : " + elapsedTime + "ms");<br />}<br /></pre><br />J'ai également créé une méthode permettant de voir l'utilisation mémoire au fur et à mesure du test.<br />Le but de cette méthode est de regarder la mémoire occupée avant et après un GC entre chaque itération du bench. Cela permettra de vérifier entre autre qu'il n'y ait pas fuite mémoire. <br /><pre class="brush: java">public static void gestionMemoire() {<br />    // Mémoire totale allouée<br />    long totalMemory = Runtime.getRuntime().totalMemory();<br />    // Mémoire utilisée<br />    long currentMemory = totalMemory - Runtime.getRuntime().freeMemory();<br />    System.out.println("Mémoire avant gc : " + (currentMemory / 1024) + "ko/" + (totalMemory / 1024) + "ko");<br />    System.gc();<br />    // Mémoire totale allouée<br />    totalMemory = Runtime.getRuntime().totalMemory();<br />    // Mémoire utilisée<br />    currentMemory = totalMemory - Runtime.getRuntime().freeMemory();<br />    System.out.println("Mémoire après gc : " + (currentMemory / 1024) + "ko/" + (totalMemory / 1024) + "ko");<br />}<br /></pre><h1> Résultats</h1>Les tests ont été menés sur un MacBookPro équipé d'un disque SSD et d'un Code i5.<br /><table class="table table-bordered"><tbody><tr><th>Étape</th><th>Temps</th><th>Mémoire occupée avant GC</th><th>Mémoire occupée après GC</th></tr><tr><td>Avant de commencer</td><td>/</td><td>1 734ko</td><td>338ko</td></tr><tr><td>Instanciation du moteur</td><td>58 222µs</td><td>14 049ko</td><td>387ko</td></tr><tr><td>Lecture du fichier (itération 1)</td><td>65 902ms</td><td>14 049ko</td><td>387ko</td></tr><tr><td>Lecture du fichier (itération 2)</td><td>65 864ms</td><td>13 796ko</td><td>341ko</td></tr><tr><td>Lecture du fichier (itération 3)</td><td>64 638ms</td><td>14 059ko</td><td>341ko</td></tr><tr><td>Lecture du fichier (itération 4)</td><td>65 214ms</td><td>13 700ko</td><td>341ko</td></tr><tr><td>Lecture du fichier (itération 5)</td><td>66 560ms</td><td>14 027ko</td><td>341ko</td></tr></tbody></table><br />Ces résultats permettent de montrer plusieurs choses : <br /><ul><li>Temps pour instancier le moteur : quasi-null</li><li>Mémoire persistante pour le moteur : quelques Ko</li><li>Performances plutôt satisfaisantes avec un peu plus d'une minute pour lire un fichier de plus de 2Go</li></ul><br />J'ai également fait du profiling avec YourKit afin de vérifier le comportement interne du moteur, cela a montré que la majorité du temps est passé dans la librairie open-csv, l'overhead du moteur est donc plutôt faible. <br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-x_0oaHl-krY/T0UwkAidkhI/AAAAAAAAHRM/o8SlmtudCpA/s1600/yourKitMoteurCsv.png" imageanchor="1"><img border="0" height="158" src="http://1.bp.blogspot.com/-x_0oaHl-krY/T0UwkAidkhI/AAAAAAAAHRM/o8SlmtudCpA/s400/yourKitMoteurCsv.png" width="400" /></a></div><br /><h1> Reproduire le bench</h1>N'hésitez pas à reproduire le bench et à me dire les résultats que vous obtenez : <br /><ul><li>Cloner le projet depuis github : <a href="https://github.com/ybonnel/BenchMoteurCsv">github.com/ybonnel/BenchMoteurCsv</a></li><li>Importer le projet en tant que projet maven dans Eclipse</li><li>Lancer d'abord le main de la classe GenerationFchierCsv afin de générer le fichier de test</li><li>Lancer ensuite le main de classe Bench afin de lancer le bench en lui-même</li></ul>Si vous connaissez d'autres parseurs CSV n'hésitez pas à ajouter des benchs dans le projet pour comparer les performances avec d'autres parseurs.
